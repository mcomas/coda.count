---
title: "The logratio-normal-multinomial distribution"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{The logratio-normal-multinomial distribution}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE} 
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = F
)
```

```{r setup, message=FALSE}
library(coda.count)
library(coda.base)
library(ggplot2)
library(ggtern)
```

The logratio-normal-multinomial (LRNM) distribution is the distribution obtained from the compounding of a normal distribution on the Simplex with the multinomial distribution. A LRNM random variable can be generated by 

1. first generating a multivariate normal random vector $\textbf{H}$ with parameters $\boldsymbol{\mu}$ and $\boldsymbol{\Sigma}$, and then 
1. generating a multinomial random vector $\textbf{X}$ with parameters $n$ and $\boldsymbol{\pi} := \lVert\text{exp}(\textbf{B}\textbf{X})\rVert_1$, where where $\textbf{B}$ is a matrix containing a basis of $\{\textbf{y} \in \mathbb{R}^{d+1}: \sum_{i=1}^{d+1} y_i = 0\}$ in columns. 

Probably, the most well-known LRNM distribution is the logistic-normal-multinomial distribution, which is the special case when $\textbf{B}=\left(\text{B}_{ij}\right)$ is given by
$$
\text{B}_{ij} = \left\{\begin{array}{cl}1 &\text{if $i=j$}\\ -1 & \text{if j = d+1}\\0 & \text{otherwise.}\end{array}\right.
$$ This special case is the logistic-normal-multinomial distribution.

With [`coda.base`](http://mcomas.net/coda.base) the matrix $\textbf{B}$ for the logistic-normal distribution can be obtained with function `alr_basis(d+1)`. This basis is known as the _additive-log-ratio_ basis.

```{r}
B = alr_basis(3)
B
```


As an example, we can generate 3 samples following a multivariate normal distribution

```{r}
library(mvtnorm)
set.seed(0)
mu = c(1,-1)
sigma = toeplitz(2:1/2)
B = coda.base::alr_basis(3)
H = rmvnorm(10, mu, sigma)
```

```{r}
COLORS = rep(c('blue','red','green','orange', 'yellow'), 2)
SHAPES = rep(c(1,16), 5)
p1 = ggplot(data=data.frame(H)) +
  geom_point(aes(x=X1,y=X2), size = 2, col = COLORS, shape = SHAPES)
p1
```

In a second step, we can use this multivariate normal realisations to obtain random vectors X, where for each realisation $\textbf{h}$ we generate a multinomial sample with certain $n$ and probability vector $\lVert e^{\text{B} \textbf{h}}\rVert_1$. In this example we can fix $n=25$.

```{r}
X = apply(H, 1,function(h){
  rmultinom(1, size = 20, prob = prop.table(exp(B%*%h)))
}) |> t()
X
```

```{r}
p2 = ggtern(data=data.frame(X)) +
  geom_mask() +
  geom_point(aes(x=X1,y=X2,z=X3), size = 2, col = COLORS, shape = SHAPES)
p2
```

```{r}
p2 +
  theme_minimal()
```


The probability density function is given by

$$
p(\textbf{x}) = \int_{\textbf{h}\in\mathbb{R}^d}\text{Norm}(\textbf{h}; \boldsymbol{\mu}, \boldsymbol{\Sigma}) \text{Mult}(\textbf{x};\lVert e^{\text{B} \textbf{h}}\rVert_1)\;\text{d}\textbf{h}
$$

where $B$ is a basis of the clr-space, i.e. $\{\textbf{y} \in \mathbb{R}^{d+1}: \sum_{i=1}^{d+1} y_i = 0\}$.

We can build a sample of a LRNM as follows:

* Firstly, for given parameters $\mu$ and $Sigma$ and a certain clr-basis, we generate a log-ratio normally distributed sample :

```{r}
set.seed(1)
N = 200
mu = c(0,1)
sigma = matrix(c(1, -0.8, 
                 -0.8, 1), nrow = 2)
B = ilr_basis(3)
P = rlrnormal(n = N, mu, sigma, B)
H = coordinates(P, B)
```

We can visualise either the compositional sample in a Ternary diagram or their coordinates (with respect basis $B$). 

```{r, warning=FALSE, out.width="45%", fig.width=4, fig.height=3.6, fig.show='hold'}
ggtern() +
  geom_mask() +
  geom_point(data = as.data.frame(P), aes(x = V1, y = V2, z = V3))
ggplot() +
  geom_point(data = as.data.frame(H), aes(x = ilr1, y = ilr2))
```

* After the logratio-normal random variables are generated, they are used to generate a new sample of counts using the multinomial distribution. With the function `rmultinomial()` we can generate that sample.

```{r}
SIZE = 8
Y = rmultinomial(size = SIZE, p = P)
```

In `coda.count` we can compound this to generations using the function `rlrnm()`:

```{r}
Y = rlrnm(n = N, size = SIZE, mu = mu, sigma = sigma, probs = TRUE)
P = attr(Y, 'probs')
```

To visualise the counting sample we can use a ternary diagram, but observations will only appear in discrete positions. In general, we call the $(K-D)$-simplex lattice the space for the $D$-part count data with size $K$.

```{r, fig.width=6, fig.height=4.8, fig.align='center'}
key = function(x) paste(x, collapse = '-')
tab = table(apply(Y, 1, key))
Yc = as.data.frame(Y[duplicated(Y),])
Yc$freq = as.vector(tab[match(apply(Yc, 1, key), names(tab))])
lbls = paste(' ', 0:SIZE, ' ')
brks = 0:SIZE/SIZE
ggtern() +
  geom_mask() +
  geom_point(data = Yc, aes(x = V1, y = V2, z = V3, col = freq), size = 3) +
  theme(tern.axis.arrow.show = T,
        tern.axis.title.show = F,
        tern.axis.arrow.text = element_text(face = 'bold')) +
  scale_color_gradient(low = 'blue', high = 'red') +
  scale_T_continuous(minor_breaks = NULL, breaks = brks, labels = lbls) +
  scale_L_continuous(minor_breaks = NULL, breaks = brks, labels = lbls) +
  scale_R_continuous(minor_breaks = NULL, breaks = brks, labels = lbls) +
  labs(col = 'Frequency')
```

For given parameters $mu$ and $\Sigma$ we can calculate the probability mass function for each element in a $(8-3)$-simplex lattice:

```{r, fig.width=6, fig.height=4.8, fig.align='center'}
SL3 = simplex_lattice(SIZE, 3)
X = as.data.frame(SL3)
X$p = apply(X, 1, dlrnm, mu, sigma)
ggtern() +
  geom_mask() +
  geom_point(data = X, aes(x = V1, y = V2, z = V3, col = p), size = 3) +
  theme(tern.axis.arrow.show = T,
        tern.axis.title.show = F,
        tern.axis.arrow.text = element_text(face = 'bold')) +
  scale_color_gradient(low = 'blue', high = 'red') +
  scale_T_continuous(minor_breaks = NULL, breaks = brks, labels = lbls) +
  scale_L_continuous(minor_breaks = NULL, breaks = brks, labels = lbls) +
  scale_R_continuous(minor_breaks = NULL, breaks = brks, labels = lbls) +
  labs(col = 'Probability')
```

For the sample `Y` we can

```{r}
fitting = fit_lrnm(Y, method = 'hermite')
```

Expected estimated posterior probabilities

```{r}
P_exp = as.data.frame(fitting$P)
tab = table(apply(P_exp, 1, key))
P_exp = P_exp[duplicated(P_exp),]
P_exp$freq = as.numeric(tab[match(apply(P_exp, 1, key), names(tab))])
H_exp = coordinates(P_exp[,1:3])
H_exp$freq = P_exp$freq
```

```{r, warning=FALSE, out.width="45%", fig.width=4, fig.height=3.6, fig.show='hold'}
ggtern() +
  geom_point(data = P_exp, aes(x = c1, y = c2, z = c3, col = freq)) +
  scale_color_gradient(low = 'blue', high = 'red')
ggplot() +
  geom_point(data = H_exp, aes(x = ilr1, y = ilr2, col = freq)) +
  scale_color_gradient(low = 'blue', high = 'red')
```


```{r}
ellipse = function(mu, sigma, p){
  s = -2 * log(1 - p);
  ev = eigen(sigma * s)
  t_ = seq(0, 2 * pi, length.out = 500)
  a = mu + t((t(ev$vectors) * sqrt(ev$values))) %*% rbind(cos(t_), sin(t_)) 
  as.data.frame(t(a))
}
coda_ellipse = function(mu, sigma, p, B = ilr_basis(length(mu) + 1)){
  composition(ellipse(mu, sigma, p), B)
}
```

```{r, eval=FALSE, include=FALSE}
SL3 = simplex_lattice(SIZE, 3)
# We calculate the posterior probabilities for each multivariate count
lM = lrnm_posterior_approx(SL3, mu, sigma, B)

H_MAX = as.data.frame(t(sapply(lM, function(l)l$mu)))
MAX = composition(H_MAX, B)
# H_E = as.data.frame(t(c_obtain_moments_lrnm_hermite(SL3, mu, sigma, ilr_basis(3), order = 10)[[1]]))
H_E = as.data.frame(t(sapply(lM, function(r) r$mu)))
E = composition(H_E, B)

mu_center = composition(mu, B)
```

```{r, fig.width=6, fig.height=4.8, fig.align='center', eval=FALSE, include=FALSE}
df_ellip0 = coda_ellipse(mu, sigma, 0.95)
p = ggtern() +
  geom_point(aes(x = mu_center[1], 
                 y = mu_center[2], 
                 z = mu_center[3]), col = 'blue') +
  geom_path(data = df_ellip0, aes(x = c1, y = c2, z = c3), col = 'blue') +
  geom_point(data=MAX,  aes(x = c1, y = c2, z = c3), col = 'red')+
  geom_point(data=E,  aes(x = c1, y = c2, z = c3))
for(i in 1:nrow(SL3)){
  df_ellip = coda_ellipse(lM[[i]]$mu, lM[[i]]$sigma, 0.95)
  df_ellip$state = i
  p = p + 
    geom_path(data = df_ellip, 
              aes(x = c1, y = c2, z = c3), alpha = 0.5, col = 'red')
}
p
```

```{r, fig.width=6, fig.height=4.8, fig.align='center', eval=FALSE, include=FALSE}
df_ellip0 = ellipse(mu, sigma, 0.95)
p = ggplot() +
  geom_point(aes(x = mu[1], y = mu[2]), col = 'blue') +
  geom_path(data = df_ellip0, aes(x = V1, y = V2), col = 'blue') +
  geom_point(data=H_MAX,  aes(x = V1, y = V2), col = 'red') +
  geom_point(data=H_E,  aes(x = V1, y = V2))
for(i in 1:nrow(SL3)){
  df_ellip = ellipse(lM[[i]]$mu, lM[[i]]$sigma, 0.95)
  p = p + 
    geom_path(data = df_ellip, 
              aes(x = V1, y = V2), alpha = 0.5, col = 'red')
}
p + coord_equal()
```


