---
title: "approx"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{approx}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(coda.count)
library(coda.base)
```

Parameters:

```{r}
x = c(0,10)
mu = 0
sigma = matrix(1) *2
inv_sigma = solve(sigma)
B = alr_basis(2)
Binv = MASS::ginv(B)
```


```{r}
f_lrnm_join = function(h_) exp(sapply(h_, l_lrnm_join_vec, x, mu = mu, inv_sigma, t(Binv)))

(f_join_area_x_fixed <- integrate(f_lrnm_join, lower = -20, upper = 10)$value)
(f_join_area_x_fixed <- c_d_lrnm_hermite(x, mu, sigma, Binv = t(Binv), order = 1000))

f_multinomial_ = function(h_) sapply(h_, function(h) gtools::ddirichlet(composition(h, B), x + 1) )
(f_multinomial_area <- integrate(f_multinomial_, -20, 10)$value)

N_posterior_approx = c_posterior_approximation(x, mu, inv_sigma, Binv = t(Binv))
f_posterior_approx_ = function(h_) dnorm(h_, N_posterior_approx[,2], sqrt(N_posterior_approx[,1]))
```



Evaluation

```{r}
h = seq(-20,20,0.01)
f_prior = dnorm(h, mu, sqrt(sigma))
f_posterior = f_lrnm_join(h)/f_join_area_x_fixed
f_multinomial = f_multinomial_(h)/f_multinomial_area
f_posterior_approx = f_posterior_approx_(h)
```


```{r}
f_max = pmax(f_prior, f_posterior, f_multinomial, f_posterior_approx)
x_lim = range(h[f_max>0.01])
y_lim = range(c(f_prior, f_posterior, f_multinomial, f_posterior_approx))
plot(h, f_posterior, type = 'l', xlim = x_lim, ylim = y_lim)
points(h, f_prior, type = 'l', col = 'red')
points(h, f_multinomial, type = 'l', col = 'blue')
points(h, f_posterior_approx, type = 'l', col = 'black', lty = 2)
```

```{r}
set.seed(2)
mu = c(0,0)
sigma = matrix(c(1,0.8,0.8,1), nrow = 2) * 10
inv_sigma = solve(sigma)
B = ilr_basis(3)
Binv = MASS::ginv(B)
X = rlrnm(n = 100, 10000, mu, sigma, B)

H_ = coordinates(X + 1, B)
mu_est = colMeans(H_)
sigma_est = cov(H_)

# c_posterior_approximation(X[15,], mu_est, solve(sigma_est), Binv = t(Binv))

for(i in 1:200){
  EST = apply(X, 1, c_posterior_approximation, mu_est, solve(sigma_est), Binv = t(Binv))
  
  mu_est = rowMeans(EST[5:6,])
  sigma_vec = rowMeans(apply(EST, 2, function(est){
    est[1:4] + c(est[5:6] %*% t(est[5:6]))
  })) - c(mu_est %*% t(mu_est))
  sigma_est = matrix(sigma_vec, nrow = 2)
}
print(mu_est)
print(sigma_est)
```


